# Signals and Related Concepts in Unix-like Operating Systems

---

### 1. What are signals in programming? How are they used in Unix-like OS?

**Signals** are asynchronous notifications sent to a process to notify it of an event. They can indicate things like:

- User interrupts (e.g., Ctrl+C sends `SIGINT`)
- Illegal memory access (`SIGSEGV`)
- Timers expiring (`SIGALRM`)
- Child process status changes (`SIGCHLD`)

**Usage:**

- Processes can register **signal handlers** to handle signals.
- Signals can interrupt normal flow, allowing processes to respond asynchronously to events.
- Used for inter-process communication and managing exceptional conditions.

---

### 2. What are software interrupts and hardware interrupts? Potential issues?

- **Hardware Interrupts:** Signals sent by hardware devices (e.g., keyboard, timer) to the CPU to indicate events needing attention.
  
- **Software Interrupts:** Triggered by software (via system calls or instructions like `int`), used to request OS services or handle exceptions.

**Potential issues:**

- **Race conditions** if interrupts occur unexpectedly.
- **Deadlocks** if interrupts disable needed resources.
- **Priority inversion** when lower-priority tasks block interrupts.
- Handling interrupts in improper context can cause instability.

---

### 3. What is synchronous and asynchronous signal? How can a process use both?

- **Synchronous Signals:** Generated by the process itself as a direct result of its actions (e.g., `SIGFPE` on division by zero, `SIGSEGV` on invalid memory access).

- **Asynchronous Signals:** Generated by external events or other processes (e.g., `SIGINT` from keyboard, `SIGUSR1` from another process).

**Process usage:**

- It can handle both by registering handlers.
- Synchronous signals often indicate errors; asynchronous signals notify events.

---

### 4. Who is responsible for generating signals?

- **Kernel:** Sends signals on behalf of hardware events, timers, or OS events.
- **Processes:** Can send signals to themselves or other processes (using `kill()` system call).
- **Users:** Via terminal input (e.g., Ctrl+C sends `SIGINT`).

---

### 5. What is a signal handler?

A **signal handler** is a function defined by a process to execute custom code when a specific signal is received. It allows the process to respond appropriately (e.g., cleanup, logging) instead of the default action (like termination).

---

### 6. Which system call is used to send a signal to a process?

```c
int kill(pid_t pid, int sig);
```
### 7. Write a program to send a signal to itself (same process)?
```c
#include <stdio.h>
#include <signal.h>
#include <unistd.h>

void handler(int sig) {
    printf("Received signal %d\n", sig);
}

int main() {
    signal(SIGINT, handler);
    pid_t pid = getpid();

    printf("Sending SIGINT to self (PID %d)...\n", pid);
    kill(pid, SIGINT);

    printf("Signal sent\n");
    return 0;
}
```
## 8. Explain the default action associated with the SIGKILL signal?

- **SIGKILL** immediately terminates the process.
- It **cannot be caught, blocked, or ignored**.
- The OS forcibly stops the process without cleanup.

---

## 9. How does a process handle a signal while executing in kernel mode?

- Signals **are not handled immediately** in kernel mode.
- The kernel marks signals as **pending** during kernel execution.
- Signal handlers run **only after the process returns to user mode**.
- This ensures user-space signal handlers do not run inside kernel context.

---

## 10. Describe the behavior of a process when it receives a SIGSEGV signal?

- `SIGSEGV` indicates a **segmentation fault** (illegal memory access).
- By default, the process **terminates and produces a core dump**.
- A process can install a signal handler to try recovery or logging, but usually, it indicates a serious programming error.
